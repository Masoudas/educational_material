/**
(Me: I think this is the same as Integration test, but I may be wrong).

These tests are large level tests, written normaly by the customer or QA people.
The intent of these tests is to ensure the functionality of a feature. We usually write 
these tests in a scripting language.

For example to test a UI, we are forced to decouple the business logic from the UI functions, so that
the test can access those functions without having to go through the UI, which lead us to a superior
design.

We want the acceptance tests to be easy to use, hence we write them in a simple text file. For example,
for the employee payroll problem we discussed in TDD_1, we can have the following test:
"""
AddEmp 1429 “Robert Martin” 3215.88
Payday
Verify Paycheck EmpId 1429 GrossPay 3215.88
"""

In this example, we add employee number 1429 to the database. His name is “Robert Martin,” and his
monthly pay is $3215.88. Next, we tell the system that it is payday and that it needs to pay all the employees.
Finally, we verify that a paycheck was generated for employee 1429 with a GrossPay field of $3215.88.

Note that the verify action is not something the user (necessarily) wants, but something our acceptance test uses.
We write an acceptance test that reads this, then the verify is a function of that test.

In the meantime, we can have transactions that are written in XML, and outputs (the check here) that are written in 
XML as well. As the operations are verified, we'll use more sophistaced forms (such as a socket o whatever).
"This is the command sent to the database for example. We could generate it from the text, or directly generate it".
<AddEmp PayType=Salaried>
    <EmpId>1429</EmpId>
    <Name>Robert Martin</Name>
    <Salary>3215.88</Salary>
</AddEmp>

"This is the command generated by the pay employe":
<Paycheck>
    <EmpId>1429</EmpId>
    <Name>Robert Martin</Name>
    <GrossPay>3215.88</GrossPay>
</Paycheck>

Notice the pressure that the acceptance tests placed upon the architecture of the payroll system. The very fact that
we considered the tests first led us to the notion of XML input and output very quickly. This architecture has
decoupled the transaction sources from the payroll application. It has also decoupled the paycheck printing mechanism
from the payroll application. These are good architectural decisions.

NOTE THAT we're writing acceptance tests in a scripting language (or text for that matter), because this allows the 
customer to verify the software in their own language, whereas unit tests are written in programming languages, because
a programmer has to deal with them.
*/

