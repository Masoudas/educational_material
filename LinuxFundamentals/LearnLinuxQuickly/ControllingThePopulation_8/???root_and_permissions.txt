

I have the following file:

---------- 1 Steve Steve 341 2017-12-21 01:51 myFile.txt

I switched the user to root in the terminal, and I have noticed the following behaviors:

    I can read this file and write to it.

    I can't execute this file.

    If I set the x bit in the user permissions (---x------) or the group permissions (------x---) or the others permissions (---------x) of the file, then I would be able to execute this file.

Can anyone explain to me or point me to a tutorial that explains all of the rules that apply when the root user is dealing with files and directories?





That's exactly like you've noticed for default permissions:

    Read & write:
    By default, Root user can access any file in the system. You may remove this access by changing attributes like explain here: chattr. This is then linked to capabilities.

    Execute:
    Root user doesn't have execution permission unless at least one of the execution bits is set.



Privileged access to files and directories is actually determined by capabilities, not just by being root or not. In practice, root usually has all possible capabilities, but there are situations where all/many of them could be dropped, or some given to other users (their processes).

In brief, you already described how the access control checks work for a privileged process. Here's how the different capabilities actually affect it:

The main capability here is CAP_DAC_OVERRIDE, a process that has it can "bypass file read, write, and execute permission checks". That includes reading and writing to any files, as well as reading, writing and accessing directories.

It doesn't actually apply to executing files that are not marked as executable. The comment in generic_permission (fs/namei.c), before the access checks for files, says that

    Read/write DACs are always overridable. Executable DACs are overridable when there is at least one exec bit set.

And the code checks that there's at least one x bit set if you're trying to execute the file. I suspect that's only a convenience feature, to prevent accidentally running random data files and getting errors or odd results.

Anyway, if you can override permissions, you could just make an executable copy and run that. (Though it might make a difference in theory for setuid files of a process was capable of overriding file permissions (CAP_DAC_OVERRIDE), but didn't have other related capabilities (CAP_FSETID/CAP_FOWNER/CAP_SETUID). But having CAP_DAC_OVERRIDE allows editing /etc/shadow and stuff like that, so it's approximately equal to just having full root access anyway.)

There's also the CAP_DAC_READ_SEARCH capability that allows to read any files and access any directories, but not to execute or write to them; and CAP_FOWNER that allows a process to do stuff that's usually reserved only for the file owner, like changing the permission bits and file group.

Overriding the sticky bit on directories is mentioned only under CAP_FOWNER, so it seems that CAP_DAC_OVERRIDE would not be enough to ignore that. (It would give you write permission, but usually in sticky directories you have that anyway, and +t limits it.)

(I think special devices count as "files" here. At least generic_permission() only has a type check for directories, but I didn't check outside of that.)