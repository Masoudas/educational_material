Note the interpretation of the following lines in a shell script:

#!/bin/bash
$1
$1=$2
eval $1=$2

    -   $1
    Inside the script, we replace the $1 with the value passed. When we try and execute this script, the line
    $1 (meaning content of variable 1) is passed to bash. Hence, if we passed for example ls, we'd have

username@host:~$ ls     # lists the current line

    -   $1=$2
    The strings are interpolated. If we pas myvar and 10 then we'd have:
username@host:~$ myvar=10     # my var is set to ten.

    The point is that this is not an assignment to variable one. In fact, shell variables are read-only as far
    as I'm concerned. Here, we're writing an expression with the CONTENT of the variable, not the variable 
    itself (which would have required something like 1=2 which makes absolutely no sense!)

    -   eval $1=$2
    The same thing as before. content of both variables are interpolated, assigned to content of 1, and then the
    command is evaluated.

Example: Consider the following script:
%%%%%%%%%%%%%%%%%%
my=ThisVar
eval $my=12
echo $ThisVar
echo $my    
# echo ${$my}   
%%%%%%%%%%%%%%%%%%

First, we set my to this string. Then, we set the content of my to 12. Finally, we print the content of ThisVar,
which is of course 12. It's always best to recall that this piece of code is being executed line by line in
bash. The last line prints ThisVar by the vay.

The line ${$my} throws an error, because the inside variable must not start with $. It will not be reinterpolated.