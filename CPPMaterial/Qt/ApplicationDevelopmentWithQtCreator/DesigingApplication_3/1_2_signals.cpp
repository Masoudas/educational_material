/**
 * Signals are emitted by an object when its internal state has changed in some way that might be interesting to 
 * the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we 
 * recommend to only emit them from the class that defines the signal and its subclasses.
 * 
 * When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal 
 * function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. 
 * Execution of the code following the emit statement will occur once all slots have returned. The situation is 
 * slightly different when using queued connections; in such a case, the code following the emit keyword will 
 * continue immediately, and the slots will be executed later.
 * 
 * If several slots are connected to one signal, the slots will be executed one after the other, in the order 
 * they have been connected, when the signal is emitted.
 * 
 * Signals are automatically generated by the moc and must not be implemented in the .cpp file. They can never 
 * have return types (i.e. use void).
 * 
 * A note about arguments: Our experience shows that signals and slots are more reusable if they do not use 
 * special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical 
 * QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting 
 * different input widgets together would be impossible. (me: Hence, don't create signals without special
 * argument types.)
 * 
 * 
 */