/**
* Type checking is performed on the code generated by template instantiation  (as if the code is written by hand).
* (Me: Hence, if we're instantiating template T{1, 2}, the error for an int type is not found until we
* create a class with int).
* 
* The fundamental weakness of the template mechanism is that it is not possible to directly 
* express requirements on a template argument (though I think they're changing it as of C++20).
* Hence, we can't write code such as:

template<Container Cont, typename Elem>
	requires Equal_comparable<Cont::value_type ,Elem>() // requirements for types Cont and Elem
int find_index(Cont& c, Elem e); // find the index of e in c

* That is, we have no way in C++ itself to directly say that Cont should be a type that can act as a
* container and that the type Elem should be a type that allows us to compare a value to an element of
* Cont .
* 
*/