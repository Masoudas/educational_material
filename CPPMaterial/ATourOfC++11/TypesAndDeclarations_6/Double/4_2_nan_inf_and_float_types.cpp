/**
* The standard says "The macro NAN expands to constant expression of type float which evaluates to a quiet 
* not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined."
* 
* It also says "There are many different NaN values, differentiated by their payloads and their sign bits. The 
* contents of the payload and the sign bit of the NaN generated by the macro NAN are implementation-defined."
* 
* There are three functions, nan(const char* arg), nanf(const char* arg) and nanl(const char* arg) that return a 
* nan. We need to supply a char string as "a narrow character string identifying the contents of a NaN."
* 
* The function 'isnan' determines if the given floating point number arg is a not-a-number (NaN) value.
* It also has a set of overloads or a function template accepting the arg argument of any integral type. 
* Equivalent to (2) (the argument is cast to double)!
* 
* -------------------------------------------------------------------------------------------------------
* The same story goes for infinity. The value std::numeric_limits<T>::infinity returns positive infinity for all
* types. it's false for bools, zero for int types, and 	HUGE_VALF for float, long and long double.
* 
* the isinf() function is exactly like the isnan function and checks for infinity. There's also an equivalent
* isfinite that checks whether the given value is finite.
*/
#include <numeric>
#include <iostream>

void infinity_vs_maximum_float() {
    constexpr double max = std::numeric_limits<double>::max();
    constexpr double inf = std::numeric_limits<double>::infinity();

    if (inf > max)
        std::cout << inf << " is greater than " << max << '\n';
}

void some_examples_of_nan() {
    double f1 = std::nan("1");
    std::uint64_t f1n; std::memcpy(&f1n, &f1, sizeof f1);
    std::cout << "nan(\"1\") = " << f1 << " (" << std::hex << f1n << ")\n";

    double f2 = std::nan("2");
    std::uint64_t f2n; std::memcpy(&f2n, &f2, sizeof f2);
    std::cout << "nan(\"2\") = " << f2 << " (" << std::hex << f2n << ")\n";
}

void which_is_nan() {
    std::cout << std::boolalpha
        << "isnan(NaN) = " << std::isnan(NAN) << '\n'   // Macro version
        << "isnan(Inf) = " << std::isnan(INFINITY) << '\n'  // Macro version, returns false
        << "isnan(0.0) = " << std::isnan(0.0) << '\n'   // false
        << "isnan(DBL_MIN/2.0) = " << std::isnan(DBL_MIN / 2.0) << '\n' // false
//        << "isnan(0.0 / 0.0)   = " << std::isnan(0.0 / 0.0) << '\n' // true
        << "isnan(Inf - Inf)   = " << std::isnan(INFINITY - INFINITY) << '\n'; // true
}

void which_is_finite() {
    std::cout << std::boolalpha
        << "isfinite(NaN) = " << std::isfinite(NAN) << '\n' // false
        << "isfinite(Inf) = " << std::isfinite(INFINITY) << '\n'    // false
        << "isfinite(0.0) = " << std::isfinite(0.0) << '\n' // true
        << "isfinite(exp(800)) = " << std::isfinite(std::exp(800)) << '\n' // false
        << "isfinite(DBL_MIN/2.0) = " << std::isfinite(DBL_MIN / 2.0) << '\n';  // yes
}