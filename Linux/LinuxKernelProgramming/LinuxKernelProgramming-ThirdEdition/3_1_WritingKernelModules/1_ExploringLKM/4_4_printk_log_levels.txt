Consider the printk function we used before:

printk(KERN_INFO "Hello, world\n");

The KERN_INFO, a macro, indicates one of the eight levels a message will be logged in a kernel. This does not imply
some kind of priority, but rather just a separator of messages. Here's the actual source file in the kernel tree:

// include/linux/kern_levels.h
#ifndef __KERN_LEVELS_H__
#define __KERN_LEVELS_H__

#define KERN_SOH "\001" /* ASCII Start Of Header */
#define KERN_SOH_ASCII '\001'

#define KERN_EMERG KERN_SOH "0" /* system is unusable */
#define KERN_ALERT KERN_SOH "1" /* action must be taken
immediately */
#define KERN_CRIT KERN_SOH "2" /* critical conditions */
#define KERN_ERR KERN_SOH "3" /* error conditions */
#define KERN_WARNING KERN_SOH "4" /* warning conditions */
#define KERN_NOTICE KERN_SOH "5" /* normal but significant
condition */
#define KERN_INFO KERN_SOH "6" /* informational */
#define KERN_DEBUG KERN_SOH "7" /* debug-level messages */

#define KERN_DEFAULT KERN_SOH "d" /* the default kernel loglevel */

It's quite obvious now that the log levels are just simple chars prepended to the log message.

Now, if we consider inside the kernel tree, we see that for example:
// drivers/char/hangcheck-timer.c
[...]
if (hangcheck_reboot) {
	printk(KERN_CRIT "Hangcheck: hangcheck is restarting the machine.\n");	// Critical information.
	emergency_restart();
} else {
[...]

// Literally, the device is on fire, and thus print an emergency message using the macro pr_emerg.
// arch/x86/kernel/cpu/mce/p5.c
[...]
pr_emerg("CPU#%d: Machine Check Exception: 0x%8X (type 0x%8X).\n",
smp_processor_id(), loaddr, lotype);

if (lotype & (1<<5)) {
pr_emerg("CPU#%d: Possible thermal failure (CPU on fire ?).\n",
smp_processor_id());
}
[...]

Finally note that if no levels are specified, the default will be 4.