The kill command can be used to interact with a process, by sending a signal to it. If we run this command with
a -l option, it will list the signals associated with it:

$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM

We can signal any of these (or their equivalent values.) The most important signals are

SIGKILL -9
SIGSTOP -19     # Freezes the process (like stopping in a debug mode.)
SIGCONT -18     # Unfreezes the process

Note that pkill is the equvialent command that uses process names
$ cmake-gui &   # Send to background
$ pkill -19  cmake-gui # Or kill -19 $(pgrep cmake-gui)
$ pkill -18  cmake-gui # Or kill -18 $(pgrep cmake-gui)

As an exercise, we can open a terminal, and then freeze it as follows:
$ kill -19 $(pgrep terminal)    # Freezes

Then, to unfreeze it, we can either look for pts with a grep command, or we can do as follows:
$ ps -fp $(pgrep bash)

Then we can unfreeze the terminal that's the parent of each.


NOTE: Often, I wonder whether signals to a background job after I bring it to foreground or not. Because even after
I terminate a background job, I still see it in the list of my jobs. The answer is that no, and I can think of
cmake-gui that if I run it in the background, I can check by sending signals to it and see that it complies with
the signals, and it does not matter whether it's still in the jobs list or not:

$ jobs
	[1]-  Running                 sleep 300 &
	[2]+  Stopped                 man ls