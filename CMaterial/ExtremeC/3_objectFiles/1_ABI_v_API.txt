The API is the set of conventions to use for accessing software. The ABI is essentially the same thing, but on a
different level.

Reminder from CPP weekly: If we had a structure for example, we couldn't just simply change the location of content
simply because the ABI would not allow us to do so, and accessing elements would cause an error. Note that even
in the case we decalare s.x, changing and recompiling the other code causes error.

For instance, a program cannot use a dynamic or static library that has a different ABI. Perhaps worse than that, 
an executable file (which is, in fact, an object file) cannot be run on a system supporting a different ABI than 
the one that the executable file was built for. A number of vital and obvious system functionalities, such as 
dynamic linking, loading an executable, and function calling convention, should be done precisely according to an 
agreed upon ABI.

The ABI usually contains:

	-	The instruction set of the target architecture, which includes the processor instructions, memory layout,
		endianness, registers, and so on.
	-	Existing data types, their sizes, and the alignment policy.
	-	The function calling convention describes how functions should be called. For example, subjects like the 
		structure of the stack frame and the pushing order of the arguments are part of it.
	-	Defining how system calls should be called in a Unix-like system.
	-	Used object file format, which we will explain in the following section, for having relocatable, executable, 
		and shared object files.
	-	Regarding object files produced by a C++ compiler, the name mangling, virtual table layout, is part of the 
		ABI.

The System V ABI is the most widely used ABI standard among Unix-like operating systems like Linux and the BSD systems. 
Executable and Linking Format (ELF) is the standard object file format used in the System V ABI.		