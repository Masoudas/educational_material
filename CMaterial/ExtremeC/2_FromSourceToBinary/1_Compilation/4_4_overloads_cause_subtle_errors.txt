Consider the example provided in 4_3. But instead, assume that we implement the add function as an overload with
four inputs:

int add(int a, int b, int c, int d) {
  return a + b + c + d;
}

Now, if we supply this source file instead of the original two argument function, we still can compile and even
get results. However:

$ ./original
Result: 2.5

% ./incorrect
Result: -163462967

What happens here? There are two points:
	-	Function names are superficial and don't actually exit in assembly
	-	Function arguments also don't exist in assembly.

The latter should be obvious, because the stack memory is just read as continues registeries, and that's why we
can supply additional arguments.

To further compare the two, we can object dump either of the above source codes:

$ objdump -d add_1.o
add_1.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   89 7d fc                mov    %edi,-0x4(%rbp)
   7:   89 75 f8                mov    %esi,-0x8(%rbp)
   a:   89 55 f4                mov    %edx,-0xc(%rbp)
   d:   89 4d f0                mov    %ecx,-0x10(%rbp)
  10:   8b 55 fc                mov    -0x4(%rbp),%edx
  13:   8b 45 f8                mov    -0x8(%rbp),%eax
  16:   01 c2                   add    %eax,%edx
  18:   8b 45 f4                mov    -0xc(%rbp),%eax
  1b:   01 c2                   add    %eax,%edx
  1d:   8b 45 f0                mov    -0x10(%rbp),%eax
  20:   01 d0                   add    %edx,%eax
  22:   5d                      pop    %rbp

$ objdump -d add_2.o
add_2.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   89 7d fc                mov    %edi,-0x4(%rbp)
   7:   89 75 f8                mov    %esi,-0x8(%rbp)
   a:   8b 55 fc                mov    -0x4(%rbp),%edx
   d:   8b 45 f8                mov    -0x8(%rbp),%eax
  10:   01 d0                   add    %edx,%eax
  12:   5d                      pop    %rbp
  13:   c3                      retq

When a function call takes place, a new stack frame is created on top of the stack. This stack frame contains both 
the arguments passed to the function and the return address.
We see that in add_1, which is the one with four parameters, four registeries are read, which is not the case for
the second one.

Note:
	Registers are locations within a CPU that can be accessed quickly. Therefore, it would be highly efficient for 
	the CPU to bring the values from main memory into its registers first, and then perform calculations on them. 
	The register %rbp is the one that points to the current stack frame, containing the arguments passed to a 
	function.

Hence, what happens when we call main is that the wrong number of registeries are filled, which causes no error,
however results in wrong results.

We could prevent this by changing the function symbol names based on the input types. This is usually referred to 
as name mangling and is mostly used in C++ because of its function overloading feature. (Note that we talk about
the symbol name, and not the actual function.)